// Generated by purs version 0.13.8

// | A Version data type corresponding to the type in Haskell's `Data.Version`
// | module, from the `base` library (that is, the Haskell standard library).
// |
// | See also [the Haskell documentation](http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Version.html).
// |
// | You might need this module in order to deal with PureScript compiler
// | versions, as they do not always have 3 components, and therefore will not
// | work with the `Data.Version` module in this package. In most other cases,
// | though, you should probably be using `Data.Version`.
"use strict";
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Identity = require("../Data.Identity/index.js");
var Data_List = require("../Data.List/index.js");
var Data_List_Types = require("../Data.List.Types/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Ordering = require("../Data.Ordering/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_Show = require("../Data.Show/index.js");
var Data_String_CodeUnits = require("../Data.String.CodeUnits/index.js");
var Data_String_Common = require("../Data.String.Common/index.js");
var Data_Unfoldable = require("../Data.Unfoldable/index.js");
var Data_Version_Internal = require("../Data.Version.Internal/index.js");
var Text_Parsing_Parser = require("../Text.Parsing.Parser/index.js");
var Text_Parsing_Parser_Combinators = require("../Text.Parsing.Parser.Combinators/index.js");

// | A version consists of any number of integer components, and any number of
// | string components.
var Version = (function () {
    function Version(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Version.create = function (value0) {
        return function (value1) {
            return new Version(value0, value1);
        };
    };
    return Version;
})();
var versionParser = (function () {
    var someAlphaNums = Data_List.some(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(Data_Version_Internal["when'"](function (c) {
        return Data_Version_Internal.isAsciiAlpha(c) || Data_Version_Internal.isDigit(c);
    }));
    var identifier = Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))((function () {
        var $28 = Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray);
        return function ($29) {
            return Data_String_CodeUnits.fromCharArray($28($29));
        };
    })())(someAlphaNums);
    var hyphen = Data_Version_Internal["match'"]("-");
    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Combinators.sepBy1(Data_Identity.monadIdentity)(Data_Version_Internal.nonNegativeInt)(Data_Version_Internal["match'"](".")))(function (as) {
        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Combinators.option(Data_Identity.monadIdentity)(Data_List_Types.Nil.value)(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(hyphen)(Text_Parsing_Parser_Combinators.sepBy(Data_Identity.monadIdentity)(identifier)(hyphen))))(function (bs) {
            return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_Version_Internal.eof)(function () {
                return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Version(as, bs));
            });
        });
    });
})();
var showVersion = function (v) {
    var prefix = function (v1) {
        return function (v2) {
            if (v2 === "") {
                return "";
            };
            return v1 + v2;
        };
    };
    var f = (function () {
        var $30 = Data_String_Common.joinWith(".");
        var $31 = Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray);
        var $32 = Data_Functor.map(Data_List_Types.functorList)(Data_Show.show(Data_Show.showInt));
        return function ($33) {
            return $30($31($32($33)));
        };
    })();
    return f(v.value0) + prefix("-")(Data_String_Common.joinWith("-")(Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(v.value1)));
};
var parseVersion = (function () {
    var $34 = Data_Function.flip(Text_Parsing_Parser.runParser)(versionParser);
    var $35 = Data_List.fromFoldable(Data_Foldable.foldableArray);
    return function ($36) {
        return $34($35(Data_String_CodeUnits.toCharArray($36)));
    };
})();
var eqVersion = new Data_Eq.Eq(function (v) {
    return function (v1) {
        return Data_Eq.eq(Data_List_Types.eqList(Data_Eq.eqInt))(v.value0)(v1.value0) && Data_Eq.eq(Data_List_Types.eqList(Data_Eq.eqString))(v.value1)(v1.value1);
    };
});
var ordVersion = new Data_Ord.Ord(function () {
    return eqVersion;
}, function (v) {
    return function (v1) {
        return Data_Semigroup.append(Data_Ordering.semigroupOrdering)(Data_Ord.compare(Data_List_Types.ordList(Data_Ord.ordInt))(v.value0)(v1.value0))(Data_Ord.compare(Data_List_Types.ordList(Data_Ord.ordString))(v.value1)(v1.value1));
    };
});
var _showVersion = new Data_Show.Show(function (v) {
    return "(Version " + (Data_Show.show(Data_List_Types.showList(Data_Show.showInt))(v.value0) + (" " + (Data_Show.show(Data_List_Types.showList(Data_Show.showString))(v.value1) + ")")));
});
module.exports = {
    Version: Version,
    showVersion: showVersion,
    versionParser: versionParser,
    parseVersion: parseVersion,
    eqVersion: eqVersion,
    ordVersion: ordVersion,
    "_showVersion": _showVersion
};
