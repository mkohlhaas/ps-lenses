// Generated by purs version 0.13.8

// | This module defines a `Version` data type, for representing software
// | versions, according to the [Semantic Versioning](http://semver.org)
// | specification. To summarize, a `Version` consists of:
// |
// | * a MAJOR, MINOR, and a PATCH component, all of which are nonnegative
// |   integers.
// | * optionally, a list of pre-release identifiers, consisting of ASCII
// |   letters, numbers, and hyphens, and which is separated from the three
// |   main components with a hyphen.
// | * optionally, build metadata, consisting of ASCII letters, numbers, and
// |   hyphens, and which is separated from the rest of the version with a plus
// |   symbol.
// |
// | Note that, according to the semver spec, version precedence must ignore
// | any build metadata. Therefore, the `Ord` instance ignores the build
// | metadata. In order to have the `Eq` instance agree with the `Ord`
// | instance, the `Eq` instance ignores build metadata too.
"use strict";
var Control_Alt = require("../Control.Alt/index.js");
var Control_Applicative = require("../Control.Applicative/index.js");
var Control_Apply = require("../Control.Apply/index.js");
var Control_Bind = require("../Control.Bind/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_HeytingAlgebra = require("../Data.HeytingAlgebra/index.js");
var Data_Identity = require("../Data.Identity/index.js");
var Data_Int = require("../Data.Int/index.js");
var Data_List = require("../Data.List/index.js");
var Data_List_Types = require("../Data.List.Types/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Ord = require("../Data.Ord/index.js");
var Data_Ordering = require("../Data.Ordering/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Data_Show = require("../Data.Show/index.js");
var Data_String_CodeUnits = require("../Data.String.CodeUnits/index.js");
var Data_String_Common = require("../Data.String.Common/index.js");
var Data_Unfoldable = require("../Data.Unfoldable/index.js");
var Data_Version_Internal = require("../Data.Version.Internal/index.js");
var Text_Parsing_Parser = require("../Text.Parsing.Parser/index.js");
var Text_Parsing_Parser_Combinators = require("../Text.Parsing.Parser.Combinators/index.js");
var IInt = (function () {
    function IInt(value0) {
        this.value0 = value0;
    };
    IInt.create = function (value0) {
        return new IInt(value0);
    };
    return IInt;
})();
var IStr = (function () {
    function IStr(value0) {
        this.value0 = value0;
    };
    IStr.create = function (value0) {
        return new IStr(value0);
    };
    return IStr;
})();

// | A semver version.
var Version = (function () {
    function Version(value0, value1, value2, value3, value4) {
        this.value0 = value0;
        this.value1 = value1;
        this.value2 = value2;
        this.value3 = value3;
        this.value4 = value4;
    };
    Version.create = function (value0) {
        return function (value1) {
            return function (value2) {
                return function (value3) {
                    return function (value4) {
                        return new Version(value0, value1, value2, value3, value4);
                    };
                };
            };
        };
    };
    return Version;
})();
var showIdentifier = function (i) {
    if (i instanceof IInt) {
        return Data_Show.show(Data_Show.showInt)(i.value0);
    };
    if (i instanceof IStr) {
        return i.value0;
    };
    throw new Error("Failed pattern match at Data.Version (line 126, column 20 - line 128, column 14): " + [ i.constructor.name ]);
};

// | Unpack a version. Useful for pattern matching.
// |
// | The reason we have this function instead of exporting the `Version`
// | constructor is that in this way we can guarantee that `Version` values are
// | always valid.
var runVersion = function (f) {
    return function (v) {
        return f(v.value0)(v.value1)(v.value2)(v.value3)(v.value4);
    };
};
var showVersion = (function () {
    var sep = function (v) {
        return function (v1) {
            if (v1 instanceof Data_List_Types.Nil) {
                return "";
            };
            return (function (v2) {
                return v + v2;
            })(Data_String_Common.joinWith(".")(Data_Functor.map(Data_Functor.functorArray)(showIdentifier)(Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(v1))));
        };
    };
    var go = function (maj) {
        return function (min) {
            return function (pat) {
                return function (pre) {
                    return function (build) {
                        return Data_String_Common.joinWith(".")(Data_Functor.map(Data_Functor.functorArray)(Data_Show.show(Data_Show.showInt))([ maj, min, pat ])) + (sep("-")(pre) + sep("+")(build));
                    };
                };
            };
        };
    };
    return runVersion(go);
})();
var preRelease = function (v) {
    return v.value3;
};
var patch = function (v) {
    return v.value2;
};
var nonneg = function (x) {
    var $44 = x < 0;
    if ($44) {
        return 0;
    };
    return x;
};

// | Construct a numeric identifier.
var numeric = function ($91) {
    return IInt.create(nonneg($91));
};

// | Smart constructor for versions. Negative integer components will be
// | replaced with zeroes.
var version = function (ma) {
    return function (mi) {
        return function (pa) {
            return function (pre) {
                return function (meta) {
                    return new Version(nonneg(ma), nonneg(mi), nonneg(pa), pre, meta);
                };
            };
        };
    };
};
var minor = function (v) {
    return v.value1;
};
var major = function (v) {
    return v.value0;
};

// | Tells you whether a version is a pre-release version; that is, if it has
// | any pre-release identifiers.
var isPreRelease = (function () {
    var $92 = Data_HeytingAlgebra.not(Data_HeytingAlgebra.heytingAlgebraBoolean);
    return function ($93) {
        return $92(Data_List["null"](preRelease($93)));
    };
})();
var ordIdentifier = new Data_Ord.Ord(function () {
    return eqIdentifier;
}, function (v) {
    return function (v1) {
        if (v instanceof IInt && v1 instanceof IStr) {
            return Data_Ordering.LT.value;
        };
        if (v instanceof IStr && v1 instanceof IInt) {
            return Data_Ordering.GT.value;
        };
        if (v instanceof IInt && v1 instanceof IInt) {
            return Data_Ord.compare(Data_Ord.ordInt)(v.value0)(v1.value0);
        };
        if (v instanceof IStr && v1 instanceof IStr) {
            return Data_Ord.compare(Data_Ord.ordString)(v.value0)(v1.value0);
        };
        throw new Error("Failed pattern match at Data.Version (line 203, column 1 - line 207, column 42): " + [ v.constructor.name, v1.constructor.name ]);
    };
});
var eqIdentifier = new Data_Eq.Eq(function (i1) {
    return function (i2) {
        return Data_Eq.eq(Data_Ordering.eqOrdering)(Data_Ord.compare(ordIdentifier)(i1)(i2))(Data_Ordering.EQ.value);
    };
});
var comparePre = function (v) {
    return function (v1) {
        if (v instanceof Data_List_Types.Nil && v1 instanceof Data_List_Types.Nil) {
            return Data_Ordering.EQ.value;
        };
        if (v instanceof Data_List_Types.Nil) {
            return Data_Ordering.GT.value;
        };
        if (v1 instanceof Data_List_Types.Nil) {
            return Data_Ordering.LT.value;
        };
        if (v instanceof Data_List_Types.Cons && v1 instanceof Data_List_Types.Cons) {
            var helper = function (v2) {
                return function (v3) {
                    if (v2 instanceof Data_List_Types.Nil && v3 instanceof Data_List_Types.Nil) {
                        return Data_Ordering.EQ.value;
                    };
                    if (v2 instanceof Data_List_Types.Nil) {
                        return Data_Ordering.LT.value;
                    };
                    if (v3 instanceof Data_List_Types.Nil) {
                        return Data_Ordering.GT.value;
                    };
                    if (v2 instanceof Data_List_Types.Cons && v3 instanceof Data_List_Types.Cons) {
                        return Data_Semigroup.append(Data_Ordering.semigroupOrdering)(Data_Ord.compare(ordIdentifier)(v2.value0)(v3.value0))(helper(v2.value1)(v3.value1));
                    };
                    throw new Error("Failed pattern match at Data.Version (line 182, column 3 - line 182, column 22): " + [ v2.constructor.name, v3.constructor.name ]);
                };
            };
            return Data_Semigroup.append(Data_Ordering.semigroupOrdering)(Data_Ord.compare(ordIdentifier)(v.value0)(v1.value0))(helper(v.value1)(v1.value1));
        };
        throw new Error("Failed pattern match at Data.Version (line 176, column 1 - line 176, column 61): " + [ v.constructor.name, v1.constructor.name ]);
    };
};
var ordVersion = new Data_Ord.Ord(function () {
    return eqVersion;
}, function (v1) {
    return function (v2) {
        var comparePre$prime = Data_Function.on(comparePre)(preRelease);
        var compareNormal = Data_Function.on(Data_Ord.compare(Data_Ord.ordArray(Data_Ord.ordInt)))(runVersion(function (ma) {
            return function (mi) {
                return function (pa) {
                    return function (v) {
                        return function (v3) {
                            return [ ma, mi, pa ];
                        };
                    };
                };
            };
        }));
        return Data_Semigroup.append(Data_Ordering.semigroupOrdering)(compareNormal(v1)(v2))(comparePre$prime(v1)(v2));
    };
});
var eqVersion = new Data_Eq.Eq(function (v1) {
    return function (v2) {
        return Data_Eq.eq(Data_Ordering.eqOrdering)(Data_Ord.compare(ordVersion)(v1)(v2))(Data_Ordering.EQ.value);
    };
});

// | Bump the patch version, and discard any prerelease identifiers and build
// | metadata.
var bumpPatch = function (v) {
    return version(major(v))(minor(v))(patch(v) + 1 | 0)(Data_List_Types.Nil.value)(Data_List_Types.Nil.value);
};

// | Bump the minor version, and discard any prerelease identifiers and build
// | metadata.
var bumpMinor = function (v) {
    return version(major(v))(minor(v) + 1 | 0)(0)(Data_List_Types.Nil.value)(Data_List_Types.Nil.value);
};

// | Bump the major version, and discard any prerelease identifiers and build
// | metadata.
var bumpMajor = function (v) {
    return version(major(v) + 1 | 0)(0)(0)(Data_List_Types.Nil.value)(Data_List_Types.Nil.value);
};
var buildMetadata = function (v) {
    return v.value4;
};
var acceptableIdentifier = function (ch) {
    return Data_Version_Internal.isDigit(ch) || (Data_Version_Internal.isAsciiAlpha(ch) || ch === "-");
};

// | Construct a textual identifier.
var textual = function (str) {
    var startsWith = function (prefix) {
        var $94 = Data_String_CodeUnits.stripPrefix(prefix);
        return function ($95) {
            return Data_Maybe.isJust($94($95));
        };
    };
    var ok = function (x) {
        return Data_Foldable.all(Data_Foldable.foldableArray)(Data_HeytingAlgebra.heytingAlgebraBoolean)(function (v) {
            return v(x);
        })([ (function () {
            var $96 = Data_HeytingAlgebra.not(Data_HeytingAlgebra.heytingAlgebraBoolean);
            return function ($97) {
                return $96(Data_Maybe.isJust(Data_Int.fromString($97)));
            };
        })(), (function () {
            var $98 = Data_HeytingAlgebra.not(Data_HeytingAlgebra.heytingAlgebraBoolean);
            var $99 = startsWith("0");
            return function ($100) {
                return $98($99($100));
            };
        })(), (function () {
            var $101 = Data_Foldable.all(Data_Foldable.foldableArray)(Data_HeytingAlgebra.heytingAlgebraBoolean)(acceptableIdentifier);
            return function ($102) {
                return $101(Data_String_CodeUnits.toCharArray($102));
            };
        })() ]);
    };
    var $85 = ok(str);
    if ($85) {
        return new Data_Maybe.Just(new IStr(str));
    };
    return Data_Maybe.Nothing.value;
};
var versionParser = (function () {
    var textIdent = Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_List.some(Text_Parsing_Parser.alternativeParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser.lazyParserT)(Data_Version_Internal["when'"](acceptableIdentifier)))(function (chars) {
        var str = Data_String_CodeUnits.fromCharArray(Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray)(chars));
        var v = textual(str);
        if (v instanceof Data_Maybe.Just) {
            return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(v.value0);
        };
        if (v instanceof Data_Maybe.Nothing) {
            return Text_Parsing_Parser.fail(Data_Identity.monadIdentity)("invalid identifier: " + str);
        };
        throw new Error("Failed pattern match at Data.Version (line 152, column 5 - line 154, column 54): " + [ v.constructor.name ]);
    });
    var intIdent = Data_Functor.map(Text_Parsing_Parser.functorParserT(Data_Identity.functorIdentity))(numeric)(Data_Version_Internal.nonNegativeInt);
    var identifier = Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(intIdent)(textIdent);
    var identifiers = Text_Parsing_Parser_Combinators.sepBy(Data_Identity.monadIdentity)(identifier)(Data_Version_Internal["match'"]("."));
    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_Version_Internal.nonNegativeInt)(function (maj) {
        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_Version_Internal["match'"]("."))(function () {
            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_Version_Internal.nonNegativeInt)(function (min) {
                return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_Version_Internal["match'"]("."))(function () {
                    return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_Version_Internal.nonNegativeInt)(function (pat) {
                        return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Combinators.option(Data_Identity.monadIdentity)(Data_List_Types.Nil.value)(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Data_Version_Internal["match'"]("-"))(identifiers)))(function (pre) {
                            return Control_Bind.bind(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Combinators.option(Data_Identity.monadIdentity)(Data_List_Types.Nil.value)(Control_Apply.applySecond(Text_Parsing_Parser.applyParserT(Data_Identity.monadIdentity))(Data_Version_Internal["match'"]("+"))(identifiers)))(function (buildMeta) {
                                return Control_Bind.discard(Control_Bind.discardUnit)(Text_Parsing_Parser.bindParserT(Data_Identity.monadIdentity))(Data_Version_Internal.eof)(function () {
                                    return Control_Applicative.pure(Text_Parsing_Parser.applicativeParserT(Data_Identity.monadIdentity))(new Version(maj, min, pat, pre, buildMeta));
                                });
                            });
                        });
                    });
                });
            });
        });
    });
})();
var parseVersion = (function () {
    var $103 = Data_Function.flip(Text_Parsing_Parser.runParser)(versionParser);
    var $104 = Data_List.fromFoldable(Data_Foldable.foldableArray);
    return function ($105) {
        return $103($104(Data_String_CodeUnits.toCharArray($105)));
    };
})();
var _showVersion = new Data_Show.Show(function (v) {
    return "(fromRight (parseVersion " + (Data_Show.show(Data_Show.showString)(showVersion(v)) + "))");
});
var _showIdentifier = new Data_Show.Show(function (v) {
    if (v instanceof IInt) {
        return "(numeric " + (Data_Show.show(Data_Show.showInt)(v.value0) + ")");
    };
    if (v instanceof IStr) {
        return "(fromJust (textual " + (Data_Show.show(Data_Show.showString)(v.value0) + "))");
    };
    throw new Error("Failed pattern match at Data.Version (line 209, column 1 - line 211, column 58): " + [ v.constructor.name ]);
});
module.exports = {
    version: version,
    runVersion: runVersion,
    major: major,
    minor: minor,
    preRelease: preRelease,
    buildMetadata: buildMetadata,
    isPreRelease: isPreRelease,
    bumpMajor: bumpMajor,
    bumpMinor: bumpMinor,
    bumpPatch: bumpPatch,
    textual: textual,
    numeric: numeric,
    showVersion: showVersion,
    parseVersion: parseVersion,
    versionParser: versionParser,
    eqVersion: eqVersion,
    ordVersion: ordVersion,
    "_showVersion": _showVersion,
    eqIdentifier: eqIdentifier,
    ordIdentifier: ordIdentifier,
    "_showIdentifier": _showIdentifier
};
