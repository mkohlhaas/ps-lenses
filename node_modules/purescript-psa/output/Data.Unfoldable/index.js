// Generated by purs version 0.13.8

// | This module provides a type class for _unfoldable functors_, i.e.
// | functors which support an `unfoldr` operation.
// |
// | This allows us to unify various operations on arrays, lists,
// | sequences, etc.
"use strict";
var $foreign = require("./foreign.js");
var Data_Function = require("../Data.Function/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Traversable = require("../Data.Traversable/index.js");
var Data_Tuple = require("../Data.Tuple/index.js");
var Data_Unfoldable1 = require("../Data.Unfoldable1/index.js");
var Data_Unit = require("../Data.Unit/index.js");

// | This class identifies (possibly empty) data structures which can be
// | _unfolded_.
// |
// | The generating function `f` in `unfoldr f` is understood as follows:
// |
// | - If `f b` is `Nothing`, then `unfoldr f b` should be empty.
// | - If `f b` is `Just (Tuple a b1)`, then `unfoldr f b` should consist of `a`
// |   appended to the result of `unfoldr f b1`.
// |
// | Note that it is not possible to give `Unfoldable` instances to types which
// | represent structures which are guaranteed to be non-empty, such as
// | `NonEmptyArray`: consider what `unfoldr (const Nothing)` should produce.
// | Structures which are guaranteed to be non-empty can instead be given
// | `Unfoldable1` instances.
var Unfoldable = function (Unfoldable10, unfoldr) {
    this.Unfoldable10 = Unfoldable10;
    this.unfoldr = unfoldr;
};
var unfoldr = function (dict) {
    return dict.unfoldr;
};
var unfoldableMaybe = new Unfoldable(function () {
    return Data_Unfoldable1.unfoldable1Maybe;
}, function (f) {
    return function (b) {
        return Data_Functor.map(Data_Maybe.functorMaybe)(Data_Tuple.fst)(f(b));
    };
});
var unfoldableArray = new Unfoldable(function () {
    return Data_Unfoldable1.unfoldable1Array;
}, $foreign.unfoldrArrayImpl(Data_Maybe.isNothing)(Data_Maybe.fromJust())(Data_Tuple.fst)(Data_Tuple.snd));

// | Replicate a value some natural number of times.
// | For example:
// |
// | ``` purescript
// | replicate 2 "foo" == (["foo", "foo"] :: Array String)
// | ```
var replicate = function (dictUnfoldable) {
    return function (n) {
        return function (v) {
            var step = function (i) {
                var $7 = i <= 0;
                if ($7) {
                    return Data_Maybe.Nothing.value;
                };
                return new Data_Maybe.Just(new Data_Tuple.Tuple(v, i - 1 | 0));
            };
            return unfoldr(dictUnfoldable)(step)(n);
        };
    };
};

// | Perform an Applicative action `n` times, and accumulate all the results.
// |
// | ``` purescript
// | > replicateA 5 (randomInt 1 10) :: Effect (Array Int)
// | [1,3,2,7,5]
// | ```
var replicateA = function (dictApplicative) {
    return function (dictUnfoldable) {
        return function (dictTraversable) {
            return function (n) {
                return function (m) {
                    return Data_Traversable.sequence(dictTraversable)(dictApplicative)(replicate(dictUnfoldable)(n)(m));
                };
            };
        };
    };
};

// | The container with no elements - unfolded with zero iterations.
// | For example:
// |
// | ``` purescript
// | none == ([] :: Array Unit)
// | ```
var none = function (dictUnfoldable) {
    return unfoldr(dictUnfoldable)(Data_Function["const"](Data_Maybe.Nothing.value))(Data_Unit.unit);
};

// | Convert a Maybe to any Unfoldable, such as lists or arrays.
// |
// | ``` purescript
// | fromMaybe (Nothing :: Maybe Int) == []
// | fromMaybe (Just 1) == [1]
// | ```
var fromMaybe = function (dictUnfoldable) {
    return unfoldr(dictUnfoldable)(function (b) {
        return Data_Functor.map(Data_Maybe.functorMaybe)(Data_Function.flip(Data_Tuple.Tuple.create)(Data_Maybe.Nothing.value))(b);
    });
};
module.exports = {
    Unfoldable: Unfoldable,
    unfoldr: unfoldr,
    replicate: replicate,
    replicateA: replicateA,
    none: none,
    fromMaybe: fromMaybe,
    unfoldableArray: unfoldableArray,
    unfoldableMaybe: unfoldableMaybe
};
